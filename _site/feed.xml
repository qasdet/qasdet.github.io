<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.2">Jekyll</generator><link href="https://qasdet.github.io/blog//blog/feed.xml" rel="self" type="application/atom+xml" /><link href="https://qasdet.github.io/blog//blog/" rel="alternate" type="text/html" /><updated>2023-06-15T02:49:39+03:00</updated><id>https://qasdet.github.io/blog//blog/feed.xml</id><title type="html">Заметки тестировщика</title><subtitle>Write an awesome description for your new site here :-)</subtitle><author><name>Riccardo Graziosi</name></author><entry><title type="html">Как защитить ваш API С помощью Аутентификации JWT в Django И Django Rest Framework</title><link href="https://qasdet.github.io/blog//blog/2023/06/15/django-rest-api.html" rel="alternate" type="text/html" title="Как защитить ваш API С помощью Аутентификации JWT в Django И Django Rest Framework" /><published>2023-06-15T00:00:00+03:00</published><updated>2023-06-15T00:00:00+03:00</updated><id>https://qasdet.github.io/blog//blog/2023/06/15/django-rest-api</id><content type="html" xml:base="https://qasdet.github.io/blog//blog/2023/06/15/django-rest-api.html"><![CDATA[<p><img src="https://images.unsplash.com/photo-1531771686035-25f47595c87a?ixlib=rb-4.0.3&amp;ixid=MnwxMjA3fDB8MHxzZWFyY2h8MzB8fGNvbXB1dGVyfGVufDB8fDB8fA%3D%3D&amp;auto=format&amp;fit=crop&amp;w=1600&amp;q=60" alt="2023-06-15-your-title.md
" /></p>

<p>JWT (Json Web Token) - одна из самых популярных систем аутентификации на основе токенов. Сторонним пакетом для аутентификации JWT является djangorestframework-simple jwt, который используется для реализации jwt auth в проекте django.</p>

<p>Установка</p>

<p>Сначала нам нужно установить простой пакет jwt в нашу систему, просто выполнив эту команду в терминале.</p>

<p><code class="language-plaintext highlighter-rouge">pip install djangorestframework-simplejwt</code></p>

<p>Настройка простого пакета JWT</p>

<p>Открытый settings.py файл и добавить просто добавьте rest_framework_simplejwt в INSTALLED_APPS.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>INSTALLED_APPS = [
     ...
     'rest_framework_simplejwt',
     ...
]
</code></pre></div></div>]]></content><author><name>Riccardo Graziosi</name></author><summary type="html"><![CDATA[]]></summary></entry><entry><title type="html">Список типов данных в Python</title><link href="https://qasdet.github.io/blog//blog/2022/04/03/tipy-dannyh.html" rel="alternate" type="text/html" title="Список типов данных в Python" /><published>2022-04-03T00:00:00+03:00</published><updated>2022-04-03T00:00:00+03:00</updated><id>https://qasdet.github.io/blog//blog/2022/04/03/tipy-dannyh</id><content type="html" xml:base="https://qasdet.github.io/blog//blog/2022/04/03/tipy-dannyh.html"><![CDATA[<p><img src="https://pythonchik.ru/pic/lb1/cover_0a082760-9b3d-4cc6-a6e7-add03e087007_big.webp" alt="" /></p>

<p>Начнём с того, что все данные в Python являются объектами. Они могут создаваться нами вручную, либо быть изначально встроенными на уровне языка. Объект можно охарактеризовать, как особую область памяти, где хранятся некоторые значения и определённые для этих значений операции.</p>

<p>Проиллюстрировать фундаментальность объектов в разрезе Питона можно, приведя пример общего вида программы на этом языке. Итак:</p>

<ol>
  <li>Программа состоит из модулей;</li>
  <li>Модуль, в свою очередь, представляет собой набор инструкций;</li>
  <li>Инструкции содержат выражения;</li>
  <li>Выражения служат для создания и обработки объектов;</li>
</ol>

<p><img src="https://pythonchik.ru/pic/lb1/intext_0b3c34eb-ec2e-4e7e-adbd-b14b695b9aeb_original.svg" alt="" /></p>

<p>Ну и вполне закономерно, что объекты можно классифицировать по их типам.
Что такое динамическая типизация</p>

<p>Прежде, чем мы приступим к рассмотрению наиболее употребляемых типов данных в Python, проведём небольшую параллель с другими языками программирования. Всё их множество можно разделить на две составляющие:</p>

<ul>
  <li>типизированные языки;</li>
  <li>нетипизированные (бестиповые) языки.</li>
</ul>

<p>Нетипизированные языки в основной своей массе сосредоточены на низком уровне, где большинство программ напрямую взаимодействует с железом. Так как компьютер “мыслит” нулями и единицами, различия между строкой и, допустим, классом для него будут заключаться лишь в наборах этих самых 0 и 1. В связи с этим, внутри бестиповых языков, близких к машинному коду, возможны любые операции над какими угодно данными. Результат на совести разработчика.</p>

<p>Python же — язык типизированный. А, раз в нём определено понятие “типа”, то должен существовать и процесс распознавания и верификации этих самых “типов”. В противном случае вероятны ситуации, когда логика кода окажется нарушенной, а программа выполнится некорректно.</p>

<p>Таким процессом и является типизация. В ходе её выполнения происходит подтверждение используемых типов и применение к ним соответствующих ограничений. Типизация может быть статической и динамической. В первом случае, проверка выполняется во время компиляции, во втором — непосредственно во время выполнения программного кода.</p>

<p>Python — язык с динамической типизацией. И здесь, к примеру, одна и та же переменная, при многократной инициализации, может являть собой объекты разных типов:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>a = 1
print(type(a))
&lt;class 'int'&gt;

a = 'one'
print(type(a))
&lt;class 'str'&gt;

a = {1: 'one'}
print(type(a))
&lt;class 'dict'&gt;
</code></pre></div></div>

<p>Нетипизированные языки в основной своей массе сосредоточены на низком уровне, где большинство программ напрямую взаимодействует с железом. Так как компьютер “мыслит” нулями и единицами, различия между строкой и, допустим, классом для него будут заключаться лишь в наборах этих самых 0 и 1. В связи с этим, внутри бестиповых языков, близких к машинному коду, возможны любые операции над какими угодно данными. Результат на совести разработчика.</p>

<p>Python же — язык типизированный. А, раз в нём определено понятие “типа”, то должен существовать и процесс распознавания и верификации этих самых “типов”. В противном случае вероятны ситуации, когда логика кода окажется нарушенной, а программа выполнится некорректно.</p>

<p>Таким процессом и является типизация. В ходе её выполнения происходит подтверждение используемых типов и применение к ним соответствующих ограничений. Типизация может быть статической и динамической. В первом случае, проверка выполняется во время компиляции, во втором — непосредственно во время выполнения программного кода.</p>

<p>Python — язык с динамической типизацией. И здесь, к примеру, одна и та же переменная, при многократной инициализации, может являть собой объекты разных типов:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>a = 1
print(type(a))
&lt;class 'int'&gt;

a = 'one'
print(type(a))
&lt;class 'str'&gt;

a = {1: 'one'}
print(type(a))
&lt;class 'dict'&gt;
</code></pre></div></div>

<p>В языке со статической типизацией такой фокус не пройдёт:</p>

<p>// код на C++</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>int main() {
   int b = 2;
   cout &lt;&lt; b &lt;&lt; "\n";
   b = "two";
   cout &lt;&lt; b &lt;&lt; "\n";
   return 0;
}

&gt; error: invalid conversion from ‘const char*’ to ‘int’ [-fpermissive]
  b = "two";
</code></pre></div></div>

<p>💭 Адепты и приверженцы разных языков часто спорят о том, что лучше: динамическая типизация или статическая, но, само собой, преимущества и недостатки есть и там, и там.</p>

<p>👍 К плюсам динамической типизации можно отнести:</p>

<ol>
  <li>Создание разнородных коллекций.
Благодаря тому, что в Python типы данных проверяются прямиком во время выполнения программного кода, ничто не мешает создавать коллекции, состоящие их элементов разных типов. Причём делается это легко и просто:</li>
</ol>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#список, элементами которого являются строка, целое число и кортеж
variety_list = ['String', 42, (5,25)]
</code></pre></div></div>

<ol>
  <li>
    <p>Абстрагирование в алгоритмах.
Создавая на Питоне, предположим, функцию сортировки, можно не писать отдельную её реализацию для строк и чисел, поскольку она и так корректно отработает на любом компарируемом множестве.</p>
  </li>
  <li>
    <p>Простота изучения.
Не секрет, что изучать Питон с нуля гораздо легче, чем, например, Java. И такая ситуация будет наблюдаться не только для этой пары. Языки с динамической типизацией в большинстве своём лучше подходят в качестве учебного инструмента для новичков в программировании.</p>
  </li>
</ol>

<p>🙁 К минусам же динамической проверки типов можно отнести такие моменты, как:</p>

<ol>
  <li>
    <p>Ошибки.
Ошибки типизации и логические ошибки на их основе. Они достаточно редки, однако зачастую весьма сложно отлавливаемые. Вполне реальна ситуация, когда разработчик писал функцию, подразумевая, что она будет принимать числовое значение, но в результате воздействия тёмной магии или банальной невнимательности, ей на вход поступает строка и …функция отрабатывает без ошибок выполнения, однако её результат, — ошибка, сам по себе. Статическая же типизация исключает такие ситуации априори.</p>
  </li>
  <li>
    <p>Оптимизация.
Статически типизированные языки обычно работают быстрее своих динамических братьев, поскольку являются более “тонким” инструментом, оптимизация которого, в каждом конкретном случае, может быть настроена более тщательно и рационально.</p>
  </li>
</ol>

<p>Так или иначе, сказать, что “одно лучше другого” нельзя. Иначе “другого” бы не было. Динамически типизированные языки экономят уйму времени при кодинге, но могут обернуться неожиданными проблемами на этапе тестирования или, куда хуже, продакшена. Однако вряд ли кто-то будет спорить с тем, что динамический Python куда более дружелюбный для новичков, нежели статический C++.
Разница между атомарными и структурными типы данных</p>

<p>По одной из классификаций все типы данных в Python делятся на атомарные и ссылочные.</p>

<p>Атомарные:</p>

<ul>
  <li>числа;</li>
  <li>строки;</li>
</ul>

<p>Ссылочные:</p>

<ul>
  <li>списки;</li>
  <li>кортежи;</li>
  <li>словари;</li>
  <li>функции;</li>
  <li>классы;</li>
</ul>

<p>Разница между этими двумя группами уходит глубоко в корни языка. Вкратце:</p>

<blockquote>
  <p>Атомарные объекты, при их присваивании, передаются по значению, а ссылочные — по ссылке</p>
</blockquote>]]></content><author><name>Riccardo Graziosi</name></author><summary type="html"><![CDATA[]]></summary></entry><entry><title type="html">Бритва Оккама: как QA принимать быстрые и правильные решения?</title><link href="https://qasdet.github.io/blog//blog/python/qa/2021/11/21/occam's-razor.html" rel="alternate" type="text/html" title="Бритва Оккама: как QA принимать быстрые и правильные решения?" /><published>2021-11-21T18:03:14+03:00</published><updated>2021-11-21T18:03:14+03:00</updated><id>https://qasdet.github.io/blog//blog/python/qa/2021/11/21/occam&apos;s-razor</id><content type="html" xml:base="https://qasdet.github.io/blog//blog/python/qa/2021/11/21/occam&apos;s-razor.html"><![CDATA[<p>«Эра цифровой революции требует быстрых решений от лидов и их сотрудников. Тестировщики часто рассматриваются как «узкое место» в процессах Agile и DevOps, несмотря на все последние достижения в индустрии автоматизации тестов. Скорость принятия решений сейчас требуется от каждого в команде, и при этом важно, чтобы эта скорость не оказывала негативного влияния на качество решений. Как профессионал-тестировщик, ты делаешь сотни решений каждый день и можешь этого не замечать. Твои решения влияют на твой личный успех, и на успех всей команды. Некоторые твои решения могут влиять на всю компанию», говорит глава QA-отдела в компании MoEngage, доставляющей около миллиарда рекламных сообщений в месяц.</p>

<p>«Жизнь кажется сложной, если приходится долго размышлять над каждым решением. Кто бы что не говорил, наш мозг способен обрабатывать лишь часть информации с должным вниманием. Существуют ограничения, и это хорошо что наш мозг приспособлен избегать перегрузки избыточной информацией. Он автоматически выбирает пути решений, предполагающие минимум усилий. Осознанно или нет, мы “срезаем путь”, это экономит время и, иногда, приносит хороший результат.</p>

<p>Ниже обсудим, как тестировщики могут делать быстрые эффективные решения, вспомнив о таком философском феномене, как “Бритва Оккама”.</p>

<p><strong>Что это?</strong>
“Бритва Оккама”, или “философская бритва” — это умственный “шорткат”, одно из главных правил, позволяющих устранить ненужные объяснения в каком-то философском вопросе. Это отличная вещь для развития критического мышления. Такие “ментальные модели” помогают отсечь логические выводы, имеющие низкую вероятность оказаться правильными, чтобы освободить свои умственные ресурсы для рассмотрения проблемы в целом.</p>

<p>Бритва Оккама — это философская модель, помогающая получить:</p>

<ol>
  <li>удовлетворительное решение</li>
  <li>быстро</li>
  <li>и с минимальным умственным трудом.</li>
</ol>

<p>Ниже рассмотрим применение Бритвы Оккама в тестировании софта, его автоматизации, и смежных областях разработки.</p>

<p><strong>Итак, режем</strong>
В XIV столетии английский философ Уильям Оккам сформулировал принцип:</p>

<p><strong>“Не стоит без нужды умножать сущности.”</strong></p>

<p>Другими словами,</p>

<p><strong>“Простейшее объяснение часто является самым правильным.”</strong></p>

<p>Имея дело с множеством конкурирующих гипотез какой-то проблемы, выбирай то, в котором меньше всего допущений. Это правило применимо в многих ситуациях, когда нужно принимать быстрые решения при минимуме информации. <strong>Бритва Оккама дает приоритет простоте над сложностью,</strong> если не доказано что сложность необходима. Детективы, доктора, и ученые применяют этот принцип в своей работе, когда ищут решения, «отрезая» сложные предположения.</p>

<p>Представим, что ты тестируешь приложение, которое создает рекламные кампании по email. Находишь баг. Разбираешься. Оказывается, какая-то сторонняя библиотека внезапно перестала работать. Твоя команда не выдавала релиз уже две недели. Ты в первую очередь инженер, поэтому ты действуешь проактивно: расследуешь почему это случилось, перед тем как завести баг. Размышляешь: а какая самая вероятная причина бага?</p>

<ol>
  <li><strong>Предположение 1.</strong> Кто-то хакнул приложение и специально вставил баг.</li>
  <li><strong>Предположение 2.</strong> Проблема возникла из-за неожиданного скачка трафика. Надо провести тест производительности и пробовать воспроизвести баг.</li>
  <li><strong>Предположение 3.</strong> Библиотека-редактор выпустила релиз прошлой ночью (как следует из их release notes), в этом-то и проблема.</li>
</ol>

<blockquote>
  <p>“Сколько раз я говорил вам, отбросьте все невозможное,  то  что
останется, и будет ответом,  каким  бы  невероятным  он  ни  казался.”
Артур Конан Дойл</p>
</blockquote>

<p>Бритва Оккама легко отсекает первое и второе предположения, и «запускает расследование» по третьему — поскольку оно самое простое, в нем меньше всего неправдоподобных допущений, и оно основано на здравом смысле, очевидности.</p>

<p>Предположения 1 и 2 также возможны — сугубо теоретически — но имеет смысл начинать дебаг, пользуясь лишь Предположением 3. Всегда начинай с простейшего предположения, и продолжай отсекать лишнее, продвигаясь к корню проблемы. Это сохраняет время и усилия. Многие из тестировщиков, сугубо из накопленного опыта, умеют отследить корень проблемы пользуясь этим принципом, даже никогда его не встретив в сформулированной форме. А осознанное применение этого принципа делает тестировщика более зрелым в профессиональном плане.</p>

<p><strong>Примечание.</strong>  Если предположение простое, оно не обязательно во всех 100% правильное. Простейшее предположение должно основываться на всех доступных данных.</p>

<p>В ИТ-индустрии существует более практическое и приближенное к ИТ изложение этого принципа — называется KISS (“Keep It Simple, Stupid” = “<code class="language-plaintext highlighter-rouge">Делай проще, тупица</code>”).</p>

<ul>
  <li>
    <p>Делай свои автотесты простыми, насколько это возможно. Убедись, что их код прост и хорошо структурирован. Избегай сложности и того что называется “over-engineering”. Жизнь будет проще, и для тебя, и для команды. Помни, что удерживать простоту не так легко, она требует хорошего планирования, и постоянного улучшения.</p>
  </li>
  <li>
    <p>При выборе фреймворка автоматизации и дополнительных инструментов руководствуйся принципом: чем проще, тем лучше. Простые инструменты позволяют создавать и обслуживать наборы тестов с удобной кривой обучаемости.</p>
  </li>
  <li>
    <p>Рост сложности означает рост стоимости обслуживания, и, неизбежно, рост количества багов. К примеру, если проект очень простой, и есть возможность использовать простые вещи, например платформу типа TestProject поддерживаемую сообществом тестировщиков, то, может быть, не стОит использовать серьезные вещи (например Selenium или Appium).</p>
  </li>
</ul>

<p>Бритва Оккама применима также в следующих сферах:</p>

<p><strong>Управление проектами.</strong> Не стоит усложнять вещи, поддерживай минимум процессов. Поощряй команду выбирать только релевантные процессы, действительно необходимые. Лишние процессы затруднят деятельность команды. Регулярно проверяй процессы, устраняй лишние, не повышающие стоимость продукта. Методики Agile и Lean созданы для простоты и инноваций, и они работают «по бритве Оккама».
<strong>Управление продуктами.</strong> Минимизируй функции. Добавляй “фичи” лишь если они действительно ценны для клиентов. Не делай продукт сложным — это отталкивает клиента.</p>

<p><img src="https://testengineer.ru/wp-content/uploads/2021/11/ms-word.jpg" alt="" /></p>

<p><strong>Дизайн интерфейсов.</strong> Выше — пример. Сосредоточься на простых пользовательских интерфейсах. Твоя цель — простота. Надо понимать, что простой интерфейс привлекает клиентов. Попробуй экспериментировать с А/B-тестированием, мультивариантным тестированием, чтобы понять, что реально нравится клиентам.</p>

<p><strong>Документация API (и документация в целом).</strong> Вместо бомбардировки пользователей избыточной информацией, пиши простые и ясные доки по API. Разработчики любят работать с API только если документация на высшем уровне, и API легко освоить.</p>

<p><strong>Коммуникация.</strong> Будь прост в общении. Критически важно доносить правильные вещи правильным людям. Например, имея дело с представителями заказчика, рассказывай о проекте с точки зрения бизнеса и функциональности. Старайся не вдаваться в технические детали. Понимай свою аудиторию, говори с людьми на их языке.</p>

<p><strong>Итак:</strong>
Поддерживать простоту — еще та задача. Но она приводит к успеху. Всегда выбирай решение простейшее из возможных. Выбирай архитектуру, дизайн, рабочий процесс, технологию, фреймворк, инструмент, исходя из их простоты. Помни о Бритве Оккама, разрабатывая автотесты и когда ищешь причину критикал-бага. Это важный инструмент, которым тестировщик должен “резать” несущественные предположения. Так достигается быстрота, и обеспечивается качество.»</p>]]></content><author><name>Riccardo Graziosi</name></author><category term="Python" /><category term="QA" /><summary type="html"><![CDATA[«Эра цифровой революции требует быстрых решений от лидов и их сотрудников. Тестировщики часто рассматриваются как «узкое место» в процессах Agile и DevOps, несмотря на все последние достижения в индустрии автоматизации тестов. Скорость принятия решений сейчас требуется от каждого в команде, и при этом важно, чтобы эта скорость не оказывала негативного влияния на качество решений. Как профессионал-тестировщик, ты делаешь сотни решений каждый день и можешь этого не замечать. Твои решения влияют на твой личный успех, и на успех всей команды. Некоторые твои решения могут влиять на всю компанию», говорит глава QA-отдела в компании MoEngage, доставляющей около миллиарда рекламных сообщений в месяц.]]></summary></entry><entry><title type="html">Менеджер пакетов PIP. Гайд по использованию</title><link href="https://qasdet.github.io/blog//blog/python/pip/2021/11/08/manager-pip.html" rel="alternate" type="text/html" title="Менеджер пакетов PIP. Гайд по использованию" /><published>2021-11-08T22:45:47+03:00</published><updated>2021-11-08T22:45:47+03:00</updated><id>https://qasdet.github.io/blog//blog/python/pip/2021/11/08/manager-pip</id><content type="html" xml:base="https://qasdet.github.io/blog//blog/python/pip/2021/11/08/manager-pip.html"><![CDATA[<p><img src="https://pythonchik.ru/pic/lb1/cover_2f7b25c2-3416-4f3e-b8ca-06f259f5644e_big.webp" alt="" /></p>

<p>PIP — это менеджер пакетов. Он позволяет устанавливать и управлять пакетами на Python.</p>

<p>Представьте себе ситуацию: вы собираете проект и подключаете множество сторонних библиотек для реализации своей задачи. Если это делать вручную, процесс выглядит примерно так:</p>

<ul>
  <li>вы заходите на сайт, выбираете нужную версию пакета;</li>
  <li>скачиваете ее, разархивируете, перекидываете в папку проекта;</li>
  <li>подключаете, прописываете пути, тестируете.</li>
</ul>

<p>Вполне вероятно, что эта версия библиотеки вообще не подходит, и весь процесс повторяется заново. А если таких библиотек 10? Устанавливать их вручную?</p>

<p>Нет 🙅🏻‍♂️</p>

<p>Менеджер пакетов PIP — решает данную проблему. Весь процесс установки пакета сводится к выполнению консольной команды <code class="language-plaintext highlighter-rouge">pip install package-name</code>. Несложно представить, сколько времени это экономит.</p>

<p>Если вы работали с другими языками программирования, концепция <code class="language-plaintext highlighter-rouge">pip</code> может показаться вам знакомой. Pip похож на <code class="language-plaintext highlighter-rouge">npm</code> (в Javascript), composer (в PHP) или gem (в Ruby).</p>

<p><code class="language-plaintext highlighter-rouge">PIP</code> является стандартным менеджером пакетов в <code class="language-plaintext highlighter-rouge">Python</code></p>

<p><strong>pip или pip3?</strong></p>

<p>В зависимости от того, какая версия Python установлена в системе, может потребоваться использовать pip3 вместо pip.</p>

<p>Если вы не знаете какая версия Python установлена на вашей системе, выполните следующие команды:</p>

<ul>
  <li>python –version — для Python 2.x</li>
  <li>python3 –version — для Python 3.x</li>
  <li>python3.8 –version — для Python 3.8.x</li>
</ul>

<blockquote>
  <p>Советуем использовать версию Python 3.6 и выше</p>
</blockquote>

<p>Далее нужно убедиться, что сам PIP установлен и работает корректно. Узнать это поможет команда:</p>

<p><code class="language-plaintext highlighter-rouge">pip --version</code></p>

<p>Команда отобразит в консоли версию pip, путь до pip и версию python, для которой в дальнейшем будут устанавливаться пакеты:</p>

<p><code class="language-plaintext highlighter-rouge">pip 19.2.3 from /usr/local/lib/python3.8/site-packages/pip (python 3.8)</code></p>

<p>☝️ Важный момент: в зависимости от того, какую версию Python вы будете использовать, команда может выглядеть как <code class="language-plaintext highlighter-rouge">pip</code> , <code class="language-plaintext highlighter-rouge">pip3</code> или <code class="language-plaintext highlighter-rouge">pip3.8</code></p>

<p>Альтернативный вариант вызова <code class="language-plaintext highlighter-rouge">pip</code>:</p>

<p><code class="language-plaintext highlighter-rouge">python3.7 -m pip install package-name</code></p>

<p>Флаг -m сообщает Python-у запустить pip как исполняемый модуль.</p>

<p><strong>Если pip не установлен</strong></p>

<p>Pip поставляется вместе с Python, и доступен после его установки. Если по какой-то причине pip не установлен на вашей системе, установить его будет не сложно.</p>

<p>Windows:</p>
<ul>
  <li>Скачайте файл get-pip.py и сохраните у себя на компьютере.</li>
  <li>Откройте командную строку и перейдите в папку, в которой сохранен get-pip.py.</li>
  <li>В командной строке выполните команду: python get-pip.py или python3 get-pip.py.</li>
  <li>PIP установлен 🎉!</li>
  <li>Linux (Ubuntu и Debian)
Прежде, чем перейти к непосредственному описанию, хотим отметить, что все команды, описанные ниже, используются от имени root пользователя. Если же вы являетесь обычным пользователем на компьютере, то потребуется использовать команду sudo, чтобы получить привилегии root.</li>
</ul>

<p>Для Питона 2-й версии, выполните команду:
<code class="language-plaintext highlighter-rouge">apt-get install python-pip</code></p>

<p>Для Питона 3-ей версии:
<code class="language-plaintext highlighter-rouge">apt-get install python3-pip</code></p>

<p>MacOS
скачайте файл get-pip.py командой curl https://bootstrap.pypa.io/get-pip.py -o get-pip.py;
запустите скачанный файл командой: python get-pip.py или python3 get-pip.py.
Должна появиться запись Successfully Installed. Процесс закончен, можно приступать к работе с PIP на MacOS!</p>

<p>Как обновить PIP
Иногда, при установке очередного пакета, можно видеть сообщение о том, что доступна новая версия pip.</p>

<p>WARNING: You are using pip version 19.2.3, however version 19.3.1 is available.
А в следующей за ней строке</p>

<p>You should consider upgrading via the ‘python -m pip install –upgrade pip’ command.
указана команда для обновления pip:</p>

<p>python -m pip install –upgrade pip
Команды PIP
Синтаксис pip выглядит следующим образом: pip + команда + доп. опции</p>

<p>pip <command /> [options]
Со всеми командами pip можно ознакомиться, выполнив pip help . Информацию по конкретной команде выведет pip help <command />.</p>

<p>Рассмотрим команды pip:</p>

<ol>
  <li><code class="language-plaintext highlighter-rouge">pip install package-name </code>— устанавливает последнюю версию пакета;</li>
  <li><code class="language-plaintext highlighter-rouge">pip install package-name==4.8.2</code> — устанавливает пакет версии 4.8.2;</li>
  <li><code class="language-plaintext highlighter-rouge">pip install package-name --upgrade</code> — обновляет версию пакета;</li>
  <li><code class="language-plaintext highlighter-rouge">pip download</code> — скачивает пакеты;</li>
  <li><code class="language-plaintext highlighter-rouge">pip uninstall</code> — удаляет пакеты;</li>
  <li><code class="language-plaintext highlighter-rouge">pip freeze</code> — выводит список установленных пакетов в необходимом формате ( обычно используется для записи в requirements.txt);</li>
  <li><code class="language-plaintext highlighter-rouge">pip list</code> — выводит список установленных пакетов;</li>
  <li><code class="language-plaintext highlighter-rouge">pip list</code> –outdated — выводит список устаревших пакетов;</li>
  <li><code class="language-plaintext highlighter-rouge">pip show</code> — показывает информацию об установленном пакете;</li>
  <li><code class="language-plaintext highlighter-rouge">pip check</code>— проверяет установленные пакеты на совместимость зависимостей;</li>
  <li><code class="language-plaintext highlighter-rouge">pip search</code> — по введенному названию, ищет пакеты, опубликованные в PyPI;</li>
  <li><code class="language-plaintext highlighter-rouge">pip wheel</code> — собирает wheel-архив по вашим требованиям и зависимостям;</li>
  <li><code class="language-plaintext highlighter-rouge">pip hash</code> — вычисляет хеши архивов пакетов;</li>
  <li><code class="language-plaintext highlighter-rouge">pip completion</code> — вспомогательная команда используется для завершения основной команды;</li>
  <li><code class="language-plaintext highlighter-rouge">pip help</code> — помощь по командам.</li>
</ol>

<p>Пример работы с пакетами
PIP позволяет устанавливать, обновлять и удалять пакеты на компьютере. Ниже попробуем разобраться с работой менеджера pip на примере парсинга названий свежих статей на сайте habr.com.</p>

<p>установим нужные пакеты;
импортируем пакет в свой скрипте;
разберемся, что такое requirements.txt;
обновим/удалим установленные пакеты.
Приступим 🙎🏻‍♂️</p>

<p><strong>Шаг #1</strong> Установка.</p>

<p>Для начала, нам необходимо установить beautifulsoup4 — библиотеку для парсинга информации с веб-сайтов.</p>

<p>pip3 install beautifulsoup4
pip найдет последнюю версию пакета в официальном репозитории pypi.org. После скачает его со всеми необходимыми зависимостями и установит в вашу систему. Если вам нужно установить определенную версию пакета, укажите её вручную:</p>

<p>pip3 install beautifulsoup4==4.8.2
Данная команда способна даже перезаписать текущую версию на ту, что вы укажите.</p>

<p>Также для работы beautifulsoup нам понадобится пакет lxml:</p>

<p>pip install lxml
☝️ Важный момент: по умолчанию pip устанавливает пакеты глобально. Это может привести к конфликтам между версиями пакетов. На практике, чтобы изолировать пакеты текущего проекта, создают виртуальное окружение (virtualenv).</p>

<p><strong>Шаг #2</strong> Импортирование в скрипте.</p>

<p>Для того чтобы воспользоваться функционалом установленного пакета, подключим его в наш скрипт, и напишем простой парсер:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#скачиваем html
from urllib.request import urlopen
from bs4 import BeautifulSoup
page = urlopen("https://habr.com/ru/top/")
content = page.read()

#сохраняем html в виде объекта BeautifulSoup
soup = BeautifulSoup(content, "lxml")

#Находим все теги "a" с классом "post__title_link"
all_a_titles = soup.findAll("a", { "class" : "post__title_link" })

#Проходим по каждому найденному тегу и выводим на экран название статьи
for a_title in all_a_titles:
    print(a_title.text)
</code></pre></div></div>

<p><strong>Шаг #3</strong> requirements.txt.</p>

<p>Если вы просматривали какие-либо проекты Python на Github или где-либо еще, вы, вероятно, заметили файл под названием requirements.txt. Этот файл используется для указания того, какие пакеты необходимы для запуска проекта (в нашем случае beautifulsoup4 и lxml).</p>

<p>Файл requirements.txt создается командой:</p>

<p>pip freeze &gt; requirements.txt
и выглядит следующим образом:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>beautifulsoup4==4.8.2
lxml==4.4.2
soupsieve==1.9.5
</code></pre></div></div>
<p>Теперь ваш скрипт вместе с файлом requirements.txt можно сохранить в системе контроля версий (например git).</p>

<p>Для работы парсера в новом месте (например на компьютере другого разработчика или на удаленном сервере) необходимо затянуть файлы из системы контроля версий и выполнить команду:
<code class="language-plaintext highlighter-rouge">pip install -r requirements.txt</code></p>

<p><strong>Шаг #4</strong> Обновление/удаление установленных пакетов.</p>

<p>Команда pip list –outdated выведет список всех устаревших пакетов. Обновить отдельно выбранный пакет поможет команда:
<code class="language-plaintext highlighter-rouge">pip install package-name --upgrade</code></p>

<p>Однако бывают ситуации, когда нужно обновить сразу все пакеты из requirements.txt. Достаточно выполнить команду:
<code class="language-plaintext highlighter-rouge">pip install -r requirements.txt --upgrade</code></p>

<p>Для удаления пакета выполните:
<code class="language-plaintext highlighter-rouge">pip uninstall package-name</code></p>

<p>Для удаления всех пакетов из requirements.txt:
<code class="language-plaintext highlighter-rouge">pip uninstall -r requirements.txt -y</code></p>]]></content><author><name>Riccardo Graziosi</name></author><category term="Python" /><category term="PIP" /><summary type="html"><![CDATA[]]></summary></entry><entry><title type="html">Дзен Python — философии программирования от Тима Петерса (PEP20)</title><link href="https://qasdet.github.io/blog//blog/python/pep20/zenpython/2021/11/08/dzen-python.html" rel="alternate" type="text/html" title="Дзен Python — философии программирования от Тима Петерса (PEP20)" /><published>2021-11-08T22:36:26+03:00</published><updated>2021-11-08T22:36:26+03:00</updated><id>https://qasdet.github.io/blog//blog/python/pep20/zenpython/2021/11/08/dzen-python</id><content type="html" xml:base="https://qasdet.github.io/blog//blog/python/pep20/zenpython/2021/11/08/dzen-python.html"><![CDATA[<p><img src="https://pythonchik.ru/pic/lb1/cover_6e9626a0-5667-4f5a-a2d5-80d992cd3d5e_big.webp" alt="" /></p>

<p><strong>Python</strong> является одним из самых простых и при этом мощных языков программирования. Он широко востребован сегодня, такие компании как IBM, Google, Facebook и многие другие создают свои продукты именно на Python. Также стоит отметить, что “Питон” — это язык программирования с большим потенциалом на будущее.</p>

<p>Для новичков этот язык очень прост в изучении, а для профессионалов он открывает большие возможности для реализации самых креативных идей, предоставляет широкий ряд инструментов для решения не только простых задач, но и сложных проектов. Все это возможно, благодаря открытости и постоянному обновлению языка.</p>

<p>Одним из важных вкладов в развитие Python стал свод правил Дзен Питон или как его еще называют PEP20 (python enhanced proposal — заявки на улучшение языка Питон) от Тима Петерсона.</p>

<p><strong>История создания PEP20</strong></p>

<p>В 1999 году Тим Петерс предложил свой свод правил по улучшению языка Питон. Дзен Python представлял собой 20 пунктов, последний из которых не был заполнен. Автор предложил написать последнее правило создателю “Питона” Гвидо Ван Россуму. Стоит отметить, что и по сей день последнее правило Дзен-философии от Тима Петерса пустое. Некоторые полагают, что таким образом автор пытался донести до нас, что правила правилами, но могут быть и исключительные ситуации, когда нужно писать код исходя из сложившихся условий, при этом игнорируя установленные нормы.</p>

<p>Сегодня этот свод правил такой же востребованный, как два десятка лет назад. Благодаря этому код, написанный с учетом PEP20, легко читаем для любого программиста. Это особенно актуально при реализации больших масштабных проектов, над созданием кода которых трудится целая группа программистов. Также читабельность кода важна при последующем сопровождении программного продукта – исправлении багов, выпуске обновлений.
Версии PEP</p>

<p>Кроме Тима Петерсона множество других заинтересованный в развитии Python людей подавали заявки на улучшение языка Питон. Каждое такое предложение получает свой номер. На сегодняшний день насчитывается порядка 8 000 таких заявок. Стоит понимать, что только часть из них были приняты. Остальные были либо оставлены на рассмотрение, либо вовсе отклонены.</p>

<p>Но те PEP, которые были приняты, в том числе и PEP под номером 20 от Тима Петерса, внесли свой вклад в развитие Питона.
PEP 20 в консоли</p>

<p>Найти Zen of Python можно на официальном сайте по языку программирования Python. Также ознакомиться с этой информацией можно в консольном приложении Python. Достаточно ввести всего одну команду import this и на экране высветиться свод из 19 правил на английском языке. Выглядит это следующим образом:</p>

<p><img src="https://pythonchik.ru/pic/lb1/intext_363bef0f-8f65-44a3-81ff-80a83ce37cf1_big.webp" alt="" /></p>

<p><strong>Zen of Python на русском языке</strong></p>

<p>PEP20, а если быть точнее, то 19 правил по улучшению языка Питон от Тима Петерса, выглядят следующим образом на русском языке:</p>

<ul>
  <li>Красивое лучше уродливого.</li>
  <li>Явное лучше неявного.</li>
  <li>Простое лучше сложного.</li>
  <li>Сложное лучше запутанного.</li>
  <li>Развернутое лучше вложенного.</li>
  <li>Разреженное лучше плотного.</li>
  <li>Читаемость имеет значение.</li>
  <li>Особые случаи не настолько особые, чтобы нарушать правила.</li>
  <li>При этом практичность важнее безупречности.</li>
  <li>Ошибки не должны замалчиваться.</li>
  <li>Если не замалчиваются явно.</li>
  <li>Встретив двусмысленность, отбрось искушение угадать.</li>
  <li>Должен существовать один - и, желательно, только один – очевидный способ сделать что-то.</li>
  <li>Хотя этот способ поначалу может быть и не очевиден, если вы не голландец.</li>
  <li>Сейчас лучше, чем никогда.</li>
  <li>Хотя никогда часто лучше, чем <em>прямо</em> сейчас.</li>
  <li>Если реализацию сложно объяснить – идея точно плоха.</li>
  <li>Если реализацию легко объяснить – возможно, идея хороша.</li>
  <li>Пространства имен – отличная штука! Будем использовать их чаще!</li>
</ul>

<p>Советы по улучшению читабельности кода на Python</p>

<p>Благодаря философии Дзен на сегодняшний день код программ на Питоне один из самых читабельных и простых. Существует свод правил, придерживаясь которым, можно написать красивый код. Итак, нужно знать следующее:</p>

<ul>
  <li>Наличие отступов в четыре символа делает код зрительно структурированным. Не стоит смешивать пробелы с табуляцией. При компиляции можно получить предупреждения от системы.</li>
  <li>Длина одной строки не должна превышать восьмидесяти символов, такой код не выглядит громоздким. Еще одно достоинство коротких строк – это возможность располагать на экране монитора сразу несколько окон с кодом.</li>
  <li>В код для разделения функций или каких-то больших логических блоков можно добавлять пустые строки.</li>
  <li>Наличие толковых комментариев облегчает последующее использование кода.</li>
</ul>

<p>Следуя этим правилам можно получить хорошо читабельный код на Python. Но, чтобы облегчить задачу, можно воспользоваться какой-нибудь современной средой разработки. Так, например, выбрав PyCharm, при нажатии клавиши “Tab” автоматически проставляется нужные четыре пробела.</p>]]></content><author><name>Riccardo Graziosi</name></author><category term="Python" /><category term="PEP20" /><category term="ZenPython" /><summary type="html"><![CDATA[]]></summary></entry><entry><title type="html">Оператор выбора в Python (if else)</title><link href="https://qasdet.github.io/blog//blog/python/2021/11/07/if-else-python.html" rel="alternate" type="text/html" title="Оператор выбора в Python (if else)" /><published>2021-11-07T21:33:18+03:00</published><updated>2021-11-07T21:33:18+03:00</updated><id>https://qasdet.github.io/blog//blog/python/2021/11/07/if-else-python</id><content type="html" xml:base="https://qasdet.github.io/blog//blog/python/2021/11/07/if-else-python.html"><![CDATA[<p><img src="https://pythonchik.ru/pic/lb1/cover_04600fd5-2ec8-4a15-9a33-ace71e5e89b5_big.jpeg" alt="" /></p>

<p><strong>Зачем нужны условные инструкции</strong></p>

<p>Фундаментальная важность условий для любого из языков программирования заключается в их возможности описывать большую часть логики работы программы.</p>

<blockquote>
  <p><code class="language-plaintext highlighter-rouge">Говоря простыми словами, конструкция if else в Python указывает интерпретатору, следует ли выполнять определенный участок кода или нет</code>.</p>
</blockquote>

<p>Как и все прочие составные инструкции языка, оператор выбора также поддерживает свойство вложенности. Это означает, что использование <code class="language-plaintext highlighter-rouge">if else</code> позволяет создавать внутри программного модуля так называемое логическое ветвление.</p>

<p><strong>Как работает if else</strong></p>

<p>Синтаксис</p>

<p>Оператор <code class="language-plaintext highlighter-rouge">if else</code> в языке Python — это типичная условная конструкция, которую можно встретить и в большинстве других языков программирования.</p>

<p>самый простой пример, где есть всего одно условие</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="n">a</span> <span class="o">=</span> <span class="mi">1</span>
<span class="k">if</span> <span class="n">a</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
    <span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">It is true</span><span class="sh">"</span><span class="p">)</span>
 
<span class="c1">#=&gt; It is true</span></code></pre></figure>

<p>Синтаксически конструкция выглядит следующим образом:</p>

<ol>
  <li>сначала записывается часть <code class="language-plaintext highlighter-rouge">if</code> с условным выражением, которое возвращает истину или ложь;</li>
  <li>затем может следовать одна или несколько необязательных частей <code class="language-plaintext highlighter-rouge">elif </code>(в других языках вы могли встречать <code class="language-plaintext highlighter-rouge">else if</code>);</li>
  <li>Завершается же запись этого составного оператора также необязательной частью else.</li>
</ol>

<p><img src="https://pythonchik.ru/pic/lb1/intext_45b0e9fc-ff4e-4c43-981e-b0fd60273af0_original.svg" alt="" /></p>

<p><strong>Принцип работы оператора выбора в Python</strong></p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="n">count</span> <span class="o">=</span> <span class="mi">1</span>
<span class="c1">#условное выражение может быть 
#сколь угодно сложным, 
#и может быть сколь угодно elif-частей
</span><span class="k">if</span> <span class="bp">True</span> <span class="ow">and</span> <span class="n">count</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">count</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
    <span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">if</span><span class="sh">"</span><span class="p">)</span>
<span class="k">elif</span> <span class="n">count</span> <span class="o">==</span> <span class="sh">'</span><span class="s">count</span><span class="sh">'</span><span class="p">:</span>
    <span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">First elif</span><span class="sh">"</span><span class="p">)</span>
<span class="k">elif</span> <span class="n">count</span> <span class="o">==</span> <span class="mf">14.2</span><span class="p">:</span>
    <span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">Second elif</span><span class="sh">"</span><span class="p">)</span>
<span class="k">elif</span> <span class="n">count</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
    <span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">Nth elif</span><span class="sh">"</span><span class="p">)</span>
<span class="k">else</span><span class="p">:</span>
    <span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">Else</span><span class="sh">"</span><span class="p">)</span>

<span class="o">&gt;</span> <span class="n">Nth</span> <span class="k">elif</span></code></pre></figure>

<p>Для каждой из частей существует ассоциированный 
с ней блок инструкций, которые выполняются в случае 
истинности соответствующего им условного выражения.</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="n">b</span> <span class="o">=</span> <span class="mi">10</span>
<span class="k">if</span> <span class="n">b</span> <span class="o">==</span> <span class="mi">10</span><span class="p">:</span>
    <span class="c1">#любое количество инструкций
</span>    <span class="nf">print</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">b</span> <span class="o">*</span> <span class="mi">15</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">b</span> <span class="o">-</span> <span class="mi">43</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">b</span> <span class="o">**</span> <span class="mf">0.5</span>
    <span class="nf">print</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
<span class="k">elif</span> <span class="n">b</span> <span class="o">==</span> <span class="mi">20</span><span class="p">:</span>
    <span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">You will not see me</span><span class="sh">"</span><span class="p">)</span>
<span class="k">else</span><span class="p">:</span>
    <span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">And me</span><span class="sh">"</span><span class="p">)</span>

<span class="o">&gt;</span> <span class="mi">10</span>
<span class="o">&gt;</span> <span class="mf">10.344080432788601</span></code></pre></figure>

<p>То есть интерпретатор начинает последовательное выполнение программы, доходит до<code class="language-plaintext highlighter-rouge">if</code> и вычисляет значение сопутствующего условного выражения. Если условие истинно, то выполняется связанный с if набор инструкций. После этого управление передается следующему участку кода, а все последующие части elif и часть <code class="language-plaintext highlighter-rouge">else</code> (если они присутствуют) опускаются.
Отступы</p>

<p>Отступы — важная и показательная часть языка Python. Их смысл интуитивно понятен, а определить их можно, как размер или ширину пустого пространства слева от начала программного кода.</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="c1">#начало кода
#код
#код
#код
</span>    <span class="c1"># начало первого отступа
</span>    <span class="c1"># первый отступ
</span>    <span class="c1"># первый отступ
</span>        <span class="c1"># начало второго отступа
</span>        <span class="c1"># второй отступ
</span>        <span class="c1"># второй отступ
</span>        <span class="c1"># конец второго отступа
</span>   <span class="c1">#конец первого отступа
</span>	</code></pre></figure>

<p>Благодаря отступам, python-интерпретатор определяет границы блоков. Все последовательно записанные инструкции, чье смещение вправо одинаково, принадлежат к одному и тому же блоку кода. Конец блока совпадает либо с концом всего файла, либо соответствует такой инструкции, которая предшествует следующей строке кода с меньшим отступом.</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="n">var_a</span> <span class="o">=</span> <span class="mi">5</span>
<span class="n">var_b</span> <span class="o">=</span> <span class="mi">10</span>
<span class="n">var_c</span> <span class="o">=</span> <span class="mi">20</span>
<span class="k">if</span> <span class="n">var_c</span><span class="o">**</span><span class="mi">2</span> <span class="o">&gt;</span> <span class="n">var_a</span> <span class="o">*</span> <span class="n">var_b</span><span class="p">:</span>
    <span class="c1"># блок №1
</span>    <span class="k">if</span> <span class="n">var_c</span> <span class="o">&lt;</span> <span class="mi">100</span><span class="p">:</span>
        <span class="c1"># блок №2
</span>        <span class="k">if</span> <span class="n">var_c</span> <span class="o">&gt;</span> <span class="mi">10</span><span class="p">:</span>
            <span class="c1"># блок №3
</span>            <span class="n">var_a</span> <span class="o">=</span> <span class="n">var_a</span> <span class="o">*</span> <span class="n">var_b</span> <span class="o">*</span> <span class="n">var_c</span>
        <span class="c1"># блок №2
</span>        <span class="n">var_b</span> <span class="o">=</span> <span class="n">var_a</span> <span class="o">+</span> <span class="n">var_c</span>
    <span class="c1"># блок №1
</span>    <span class="n">var_c</span> <span class="o">=</span> <span class="n">var_a</span> <span class="o">-</span> <span class="n">var_b</span>
<span class="nf">print</span><span class="p">(</span><span class="n">var_a</span><span class="p">)</span>
<span class="nf">print</span><span class="p">(</span><span class="n">var_b</span><span class="p">)</span>
<span class="nf">print</span><span class="p">(</span><span class="n">var_c</span><span class="p">)</span>

<span class="o">&gt;</span> <span class="mi">1000</span>
<span class="o">&gt;</span> <span class="mi">1020</span>
<span class="o">&gt;</span> <span class="o">-</span><span class="mi">20</span></code></pre></figure>

<p>Таким образом, с помощью отступов появляется возможность создавать блоки на различной глубине вложенности, следуя простому принципу: чем глубже блок, тем шире отступ.</p>]]></content><author><name>Riccardo Graziosi</name></author><category term="Python" /><summary type="html"><![CDATA[]]></summary></entry><entry><title type="html">Как работает Python: интерпретатор, байт-код, PVM!</title><link href="https://qasdet.github.io/blog//blog/python/pvm/2021/11/07/Python-PVM.html" rel="alternate" type="text/html" title="Как работает Python: интерпретатор, байт-код, PVM!" /><published>2021-11-07T21:26:23+03:00</published><updated>2021-11-07T21:26:23+03:00</updated><id>https://qasdet.github.io/blog//blog/python/pvm/2021/11/07/Python-PVM</id><content type="html" xml:base="https://qasdet.github.io/blog//blog/python/pvm/2021/11/07/Python-PVM.html"><![CDATA[<p><strong>Python</strong> — интерпретируемый язык программирования. Он не конвертирует свой код в машинный, который понимает железо (в отличие от С и С++). Вместо этого, Python-интерпретатор переводит код программы в байт-код, который запускается на виртуальной машине Python (PVM). Давайте рассмотрим подробнее, как это работает на примере самой популярной реализации интерпретатора — CPython.</p>

<p><strong>Интерпретатор</strong> — это программа, которая конвертирует ваши инструкции, написанные на Python, в байт-код и выполняет их. По сути интерпретатор — это программный слой между вашим исходным кодом и железом.</p>

<p>Существует 2 типа интерпретаторов:</p>

<ul>
  <li>Простой интерпретатор. Он берет одну инструкцию, транслирует и сразу выполняет ее, а затем берет следующую инструкцию.</li>
  <li>Интерпретатор компилирующего типа. Это система из компилятора и интерпретатора. Компилятор переводит исходный код программы в промежуточное представление (байт-код), а интерпретатор (виртуальная машина) выполняет этот байт-код.</li>
</ul>

<p>CPython:</p>

<ul>
  <li>Интерпретатор компилирующего типа (благодаря этому достигается большее быстродействие выполнения программ).</li>
  <li>Считается эталонной реализацией языка Python.</li>
  <li>Написан на C.</li>
  <li>Исходный код CPython находится в открытом доступе.</li>
  <li>Его разработка ведётся группой разработчиков под руководством Гвидо ван Россума — создателя Python.</li>
</ul>

<p>Кроме этого, у интерпретатора** CPython** есть особенность — он может работать в режиме диалога (REPL — read-eval-print loop). Интерпретатор считывает законченную конструкцию языка, выполняет её, печатает результаты и переходит к ожиданию ввода пользователем следующей конструкции.</p>

<p><strong>Как CPython выполняет программы</strong></p>

<p>Интерпретатор “Питона” выполняет любую программу поэтапно.</p>

<p><img src="https://pythonchik.ru/pic/lb1/intext_630d6d5f-9f11-467b-afbb-73fc6c7f01df_original.svg" alt="" /></p>

<p><strong>Этап #1. Инициализация</strong></p>

<p>После запуска вашей программы, Python-интерпретатор читает код, проверяет форматирование и синтаксис. При обнаружении ошибки он незамедлительно останавливается и показывает сообщение об ошибке.</p>

<p>Помимо этого, происходит ряд подготовительных процессов:</p>

<ul>
  <li>анализ аргументов командной строки;</li>
  <li>установка флагов программы;</li>
  <li>чтение переменных среды и т.д.</li>
</ul>

<p><strong>Этап #2. Компиляция</strong></p>

<p>Интерпретатор транслирует (переводит) исходные инструкции вашей программы в байт-код (низкоуровневое, платформонезависимое представление исходного текста). Такая трансляция необходима в первую очередь для повышения скорости — байт-код выполняется в разы быстрее, чем исходные инструкции.</p>

<p><img src="https://pythonchik.ru/pic/lb1/intext_77d40039-3934-4cbd-a2b8-8ceb818ef641_original.svg" alt="" /></p>

<p>Если Python-интерпретатор обладает правом записи, он будет сохранять байт-код в виде файла с расширением .pyc. Если исходный текст программы не изменился с момента последней компиляции, при следующем запуске вашей программы, Python сразу загрузит файл .pyc, минуя этап компиляции (тем самым ускорит процесс запуска программы).
Этап #3. Выполнения</p>

<p>Как только байт-код скомпилирован, он отправляется на виртуальную машину Python (PVM). Здесь выполняется байт-код на PVM. Если во время этого выполнения возникает ошибка, то выполнение останавливается с сообщением об ошибке.</p>

<p>PVM является частью Python-интерпретатора. По сути это просто большой цикл, который выполняет перебор инструкций в байт-коде и выполняет соответствующие им операции.
Альтернативы CPython</p>

<p>CPython является стандартной реализацией, но существуют и другие реализации, созданные для специфических целей и задач.</p>

<p><strong>Jython</strong></p>

<p>Основная цель данный реализации — тесная интеграция с языком Java. Работает следующим образом:</p>

<ul>
  <li>Java-классы выполняют компиляцию программного кода на языке Python в байт-код Java.</li>
  <li>Полученный байт-код запускается на виртуальной машине Java (JVM).</li>
</ul>

<p>Jython позволить Python-программам управлять Java-приложениями. Во время выполнения такая программа ведет себя точно так же, как настоящая программа на языке Java.
IronPython</p>

<p>Предназначена для обеспечения интеграции Python-программ с C# приложениями на Microsoft .NET Framework или Mono. Принцип работы такой же, как и у Jython.</p>

<p><strong>PyPy</strong></p>

<p>PyPy — это интерпретатор Python, написанный на Python (если быть точнее, то на RPython).</p>

<p>Особенностью PyPy является использование трассирующего JIT-компилятора (just-in-time), который на лету транслирует некоторые элементы в машинный код. Благодаря этому, при выполнении некоторых операций PyPy обгоняет CPython в несколько раз. Но плата за такую производительность — более высокое потребление памяти.</p>]]></content><author><name>Riccardo Graziosi</name></author><category term="Python" /><category term="PVM" /><summary type="html"><![CDATA[Python — интерпретируемый язык программирования. Он не конвертирует свой код в машинный, который понимает железо (в отличие от С и С++). Вместо этого, Python-интерпретатор переводит код программы в байт-код, который запускается на виртуальной машине Python (PVM). Давайте рассмотрим подробнее, как это работает на примере самой популярной реализации интерпретатора — CPython.]]></summary></entry></feed>